#!/usr/bin/env perl
# bereite zur Zeitung auf

#    use v5.12;
use feature 'unicode_strings';
use feature 'say';

use Data::Dumper;
use Email::Address;
use Getopt::Std;
use App::Feedmailer;
use Text::Wrap;
use DateTime;
use List::Util;
use Encode;    # my $text = Encode::decode('UTF-8', $text);

#use locale;
use utf8;
use open ':std',
    ':encoding(UTF-8)';    # Optional, also affects STDIN/STDOUT/STDERR
binmode( STDIN,  ":encoding(UTF-8)" );    # binmode(STDIN, ":utf8");
binmode( STDOUT, ":encoding(UTF-8)" );    # binmode(STDOUT, ":utf8");
binmode( STDERR, ":encoding(UTF-8)" );    # binmode(STDERR, ":utf8");

our @entries;
our $count_of_entrys = 0;
our %opts;
our %headlines;
getopts( "ab:Csx:zf:NFi:vw:p:", \%opts )
    || die $!;
$opts{x} //= "newspaper.tt.txt";

@App::Feedmailer::whitelist = (".*");     #: shared;
if ( !$opts{F} ) {
    if ( $opts{w} ) {
        $App::Feedmailer::WHITELIST_FILE = $opts{w};
    }
    App::Feedmailer::file2list(
        \@App::Feedmailer::whitelist,
        $App::Feedmailer::WHITELIST_FILE,
        { mode => Fcntl::O_RDONLY }
    );
}

if ( $opts{b} ) {
    $App::Feedmailer::BLACKLIST_FILE = $opts{b};
}
App::Feedmailer::file2list(
    \@App::Feedmailer::blacklist,
    $App::Feedmailer::BLACKLIST_FILE,
    { mode => Fcntl::O_RDONLY }
);

my $parser = DateTime::Format::Strptime->new(
    pattern  => '%Y-%m-%d-%H-%M-%S',
    on_error => sub { warn Dumper $@, return DateTime->now; }
    ,    # 'undef', # 'croak',
);

sub handler_start {
    my ($uri) = @_;

    $uri = URI->new( $uri, "https" )
        || return;

    my $response = App::Feedmailer::download(
        $uri,
        {   ua                  => $App::Feedmailer::ua,
            proxy               => $opts{p},
            force_secure_scheme => $opts{s},
        }
    ) || return;

    if ( !$opts{C} ) {
        my $canonical_uri = App::Feedmailer::get_canonical( $uri, $response );
        if ($canonical_uri) {
            $uri = $canonical_uri;
        }
    }

    my $p = HTML::HeadParser->new();
    $p->parse( $response->decoded_content() );

    my $author = $p->header('X-Meta-Author');
    $author = join ", ", Email::Address->parse($author);

    my $dt   = $p->header('X-Meta-Date') || DateTime->now();
    my $date = $parser->parse_datetime($dt);

    my $host = $uri->host();

    my $link = $uri->as_string();

    my $summary
        = App::Feedmailer::clean_up( $p->header('X-Meta-Description') || "" );
    my $summary_wrap = Text::Wrap::wrap( "", "", $summary );

    my $title      = App::Feedmailer::clean_up( $p->header('Title') || "" );
    my $title_wrap = Text::Wrap::wrap( "", "", $title );

    return {
        'replace' => {
            '%' => '%',
            'e' => $title,
            'l' => $link,
        },
        'author'       => $author,
        'date'         => $date,
        'host'         => $host,
        'link'         => $link,
        'summary'      => $summary,
        'summary_wrap' => $summary_wrap,
        'title'        => $title,
        'title_wrap'   => $title_wrap,
    };
}

sub handler_stop {
    push( @entries, @_ );
}

sub get_matchlist {
    my ($string) = @_;
    my @matchlist;
    for (@App::Feedmailer::whitelist) {
        my ( $ig, $re, $list ) = App::Feedmailer::ig(
            $string,
            {   whitelist => \@App::Feedmailer::whitelist,
                blacklist => \@App::Feedmailer::blacklist
            }
        );
        if ( $string =~ m/$_/i && !$ig ) {
            push @matchlist, $_;
            last if ( !$opts{a} );   # News nur in die erste Headline einfügen
        }
    }
    return @matchlist;
}

for (<>) {
    chomp;
    my $uri = URI->new($_);
    if ( !$uri ) {
        warn $_, ": Not an URI";
        next;
    }
    threads->create( { "context" => "list" }, \&handler_start, $uri );
    App::Feedmailer::loop_threads( \&handler_stop );
}
App::Feedmailer::loop_last_threads( \&handler_stop );

for (@entries) {
    for my $match ( get_matchlist( $_->{title} ) ) {
        $headlines{$match}{count}++;
        push @{ $headlines{$match}{entries} }, $_;
    }
}

for (@App::Feedmailer::whitelist) {

    if ( !$opts{z} && $headlines{$_}{count} == 0 ) {

        # kein News für die Headline
        next;
    }

    if ( !$opts{N} ) {
        say "";
        say uc "$headlines{$_}{count}	$_";
        say "";
    }

    my $template = $opts{x};
    next if ( !$template );

    for ( @{ $headlines{$_}{entries} } ) {
        $count_of_entrys++;

        my $tt_data = "";
        my $tt_vars = {
            'author'       => $_->{'author'},
            'date'         => $_->{'date'},
            'host'         => $_->{'host'},
            'link'         => $_->{'link'},
            'summary'      => $_->{'summary'},
            'summary_wrap' => $_->{'summary_wrap'},
            'title'        => $_->{'title'},
            'title_wrap'   => $_->{'title_wrap'},
        };

        $App::Feedmailer::tt->process( $template, $tt_vars, \$tt_data )
            || return $App::Feedmailer::tt->error;
        say $tt_data;
    }
}

exit( !$count_of_entrys );

